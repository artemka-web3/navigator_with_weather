<!--TODO: добавить скорость ветра слой-->
<!DOCTYPE html>
<html class='use-all-space'>
<head>
    <meta http-equiv='X-UA-Compatible' content='IE=Edge' />
    <meta charset='UTF-8'>
    <title>Maps SDK for Web - Routing with draggable marker and my location</title>
    <meta name='viewport' content='width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no'/>
    <link rel='stylesheet' type='text/css' href='https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.1/maps/maps.css'>
    <link rel='stylesheet' type='text/css' href='../assets/ui-library/index.css'/>
    <link rel='stylesheet' type='text/css' href='https://api.tomtom.com/maps-sdk-for-web/cdn/plugins/SearchBox/3.2.0/SearchBox.css'/>
    <link rel='stylesheet' type='text/css' href='../assets/ui-library/icons-css/routing.css'/>
</head>
<style>
    /* Add these styles */
    .finish-weather-marker {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
    }

    .finish-weather-marker .weather-icon {
        width: 40px;
        height: 40px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
    }

    .finish-weather-marker .weather-info {
        background: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .search-panel {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        right: 80px !important;
        padding: 10px 20px !important;
    }


    /* Add styles for confirmation popup */
    .confirmation-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        z-index: 2000;
        display: none;
    }

    .confirmation-buttons {
        display: flex;
        justify-content: space-between;
        margin-top: 15px;
        gap: 10px;
    }

    .confirmation-buttons button {
        padding: 8px 20px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }

    .confirm-yes {
        background: #4CAF50;
        color: white;
    }

    .confirm-no {
        background: #f44336;
        color: white;
    }

    .search-panel .tt-search-box {
        width: 100% !important;
        max-width: none !important;
        margin: 0 auto !important;
    }

    .search-panel .tt-search-box-input {
        width: 100% !important;
        height: 44px !important;
        font-size: 16px !important;
        padding: 8px 12px !important;
    }

    .icon-wrapper {
        width: 100% !important;
    }
    .weather-marker {
        width: 50px !important;
        height: 50px !important;
        display: block !important;
        opacity: 1 !important;
        pointer-events: auto !important;
        z-index: 1000 !important;
    }

    .mapboxgl-marker {
        display: block !important;
        opacity: 1 !important;
        z-index: 1000 !important;
    }

    /* Adjust icon size based on zoom level */
    @media (max-width: 768px) {
        .weather-marker {
            width: calc(10vw + 15px);
        }
    }

    @media (max-width: 768px) {
        .search-panel {
            padding: 10px !important;
        }
    }
    .tt-icon {
        width: 24px !important;
        height: 24px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        margin: auto !important;
    }

    .tt-icon.-white {
        color: white !important;
    }

    .tt-icon.-finish {
        background: url('../assets/ui-library/icons/finish.svg') no-repeat center !important;
        background-size: contain !important;
    }

    .tt-icon.-start {
        background: url('../assets/ui-library/icons/start.svg') no-repeat center !important;
        background-size: contain !important;
    }

    /* Ensure marker wrapper is properly sized */
    .mapboxgl-marker > div {
        width: 100% !important;
        height: 100% !important;
    }
    /* Add your styles here */
    .draggable-marker {
        width: 32px !important;
        height: 32px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        background-color: #4a90e2 !important;
        border: solid 3px #2faaff !important;
        border-radius: 50% !important;
        cursor: pointer !important;
        transform-origin: center !important;
    }
    .map-view .draggable-marker {
        align-items: center;
        background-color: #4a90e2;
        border: solid 3px #2faaff;
        border-radius: 50%;
        display: flex;
        height: 32px;
        justify-content: center;
        transition: width .1s, height .1s;
        width: 32px;
    }
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
        font-family: Arial, sans-serif;
    }
    .menu {
        background-color: #333;
        overflow: hidden;
        display: flex;
        justify-content: center;
        padding: 10px 0;
        position: absolute;
        bottom: 0;
        width: 100%;
        z-index: 1000;
    }
    .menu a {
        color: #f2f2f2;
        text-align: center;
        padding: 14px 20px;
        text-decoration: none;
        font-size: 24px;
        transition: background-color 0.3s, color 0.3s;
    }
    .menu a:hover {
        background-color: #ddd;
        color: black;
    }
    .map-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        width: 100%;
        height: 100%;
    }
    #map {
        flex: 1;
        width: 100%;
        height: 100%;
        touch-action: pan-x pan-y;
    }
    .leaflet-control-layers {
        max-height: 300px;
        overflow-y: auto;
    }
    .tt-search-box {
        width: 100% !important;
    }
    .tt-search-box-input {
        width: calc(100% - 25px) !important;
    }
    .tt-search-box-result-list {
        width: 100% !important;
        max-width: none !important;
    }
    .tt-search-box-result {
        width: 100% !important;
        white-space: normal !important;
        word-wrap: break-word !important;
    }
    .tt-top-right {
        right: 10px !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
    }

    /* Stack controls vertically */
    .tt-top-right .tt-control-group {
        display: flex !important;
        flex-direction: column !important;
        gap: 10px !important;
    }
    .tt-control-button {
        margin: 5px 0 !important;
    }
    @media (max-width: 768px) {
        .search-panel {
            right: 60px !important;
            padding: 10px !important;
        }
        .leaflet-control-layers {
            max-height: 200px;
        }
    }
    /* Add styles for reset button */
    .reset-button {
        position: fixed !important;
        bottom: 90px !important; /* Position below location button */
        right: 30px !important;
        width: 50px !important;
        height: 50px !important;
        border-radius: 50% !important;
        background: white !important;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
        border: none !important;
        cursor: pointer !important;
        z-index: 1000 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 12px !important;
        transition: transform 0.2s, background-color 0.2s !important;
    }

    .reset-button:hover {
        background: #f5f5f5 !important;
        transform: scale(1.1) !important;
    }
    .follow-button {
        position: fixed !important;
        bottom: 30px !important; /* Move from top to bottom */
        right: 30px !important;
        width: 50px !important;
        height: 50px !important;
        border-radius: 50% !important;
        background: white !important;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
        border: none !important;
        cursor: pointer !important;
        z-index: 1000 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 12px !important;
        transition: transform 0.2s, background-color 0.2s !important;
    }
    .follow-button, .reset-button {
        z-index: 1001 !important; /* Higher than navigation panel */
    }

    .follow-button:hover {
        background: #f5f5f5 !important;
        transform: scale(1.1) !important;
    }

    .location-arrow {
        width: 100% !important;
        height: 100% !important;
        fill: #4a90e2 !important;
    }

    /* Make sure arrow is visible */
    .follow-button svg {
        display: block !important;
        width: 100% !important;
        height: 100% !important;
    }
    .map-view {
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
    }
    .navigation-panel {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(0, 0, 0, 0.8); /* Dark semi-transparent background */
        color: white; /* White text */
        padding: 16px;
        box-shadow: 0 -2px 10px rgba(0,0,0,0.2);
        z-index: 1000;
    }

    .hidden {
        transform: translateY(100%);
    }

    .nav-header {
        display: flex;
        justify-content: space-between;
        margin-bottom: 12px;
        font-size: 18px;
        font-weight: bold;
    }

    .nav-instruction {
        padding: 12px;
        background: rgba(255, 255, 255, 0.1); /* Subtle light background */
        border-radius: 8px;
        margin-bottom: 12px;
        color: white;
    }

    .nav-controls {
        display: flex;
        gap: 12px;
    }

    .nav-controls button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 24px;
        font-size: 16px;
        cursor: pointer;
    }
    .driving-mode .map-view {
        height: 100vh;
    }

    .driving-mode .navigation-panel {
        position: fixed;
        bottom: 0;
        width: 100%;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 20px;
        z-index: 1000;
    }
    #finishSearchBox {
        width: 100% !important;
    }
    .control-buttons {
        position: fixed;
        right: 30px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 20px;
        z-index: 1002;
    }
    .wind-button,
    .reset-button,
    .follow-button {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        background: white;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        border: none;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        transition: transform 0.2s, background-color 0.2s;
    }
    .wind-button:hover,
    .reset-button:hover,
    .follow-button:hover {
        background: #f5f5f5;
        transform: scale(1.1);
    }
    .navigation-active .control-buttons {
        right: 30px;
        top: 50%;
        transform: translateY(-50%);
    }
    .wind-button.active {
        background: #4a90e2;
    }

    .wind-button.active svg {
        fill: white;
    }
    .wind-button {
        position: fixed !important;
        bottom: 150px !important; /* Above reset button */
        right: 30px !important;
        width: 50px !important;
        height: 50px !important;
        border-radius: 50% !important;
        background: white !important;
        box-shadow: 0 4px 8px rgba(0,0,0,0.2) !important;
        border: none !important;
        cursor: pointer !important;
        z-index: 1000 !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 12px !important;
        transition: transform 0.2s, background-color 0.2s !important;
    }

    .wind-button:hover {
        background: #f5f5f5 !important;
        transform: scale(1.1) !important;
    }

    .wind-button.active {
        background: #4a90e2 !important;
    }

    .wind-button.active svg {
        fill: white !important;
    }
    #windButton {
        /* Add these styles to your CSS */
        cursor: pointer;
    }

    #windButton.active {
        background-color: #4CAF50;
        color: white;
    }

    #windButton:disabled {
        cursor: wait;
        opacity: 0.6;
    }
    #geolocation-error {
        animation: fadeIn 0.3s ease-in;
    }
    /* Add these styles */
    .marker-container {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .finish-point-marker {
        width: 32px;
        height: 32px;
        background: white;
        border-radius: 50%;
        border: 3px solid #4a90e2;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Styles for weather marker */
    .weather-marker {
        display: flex;
        flex-direction: column;
        align-items: center;
        background: white;
        padding: 5px;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .weather-icon {
        width: 32px;
        height: 32px;
        background-size: cover;
        background-position: center;
    }

    .weather-temp {
        font-size: 12px;
        font-weight: bold;
        margin-top: 4px;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translate(-50%, -20px); }
        to { opacity: 1; transform: translate(-50%, 0); }
    }

    .navigation-active .follow-button {
        bottom: 220px !important; /* Above navigation panel */
    }
    .navigation-active .reset-button {
        bottom: 280px !important;
    }
    .navigation-active .wind-button {
        bottom: 340px !important;
    }
</style>
<body>
    <div class='map-view'>
        <div id='map' class='map'>
            <div id='foldable' class='tt-overlay-panel search-panel js-foldable'>
                <div class='icon-wrapper'>
                    <div class='tt-icon icon-spacing -finish'></div> 
                    <div id='finishSearchBox' class='tt-form-label'></div>
                </div>
            </div>
            
        </div>
        <div class="control-buttons">
            <button class="wind-button" id="windButton">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="#4a90e2">
                    <path d="M14.5 17.5c0-1.65-1.35-3-3-3h-7v-2h7c2.76 0 5 2.24 5 5s-2.24 5-5 5-5-2.24-5-5h2c0 1.65 1.35 3 3 3s3-1.35 3-3zM19 6.5h-7c-2.76 0-5 2.24-5 5s2.24 5 5 5h7v2h-7c-3.87 0-7-3.13-7-7s3.13-7 7-7h7v2z"/>
                </svg>
            </button>
            <button class="reset-button" id="resetButton">
                <svg viewBox="0 0 24 24" width="24" height="24" fill="#4a90e2">
                    <path d="M17.65 6.35A7.958 7.958 0 0012 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08A5.99 5.99 0 0112 18c-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                </svg>
            </button>
            <button class="follow-button" id="followButton">
                <svg class="location-arrow" viewBox="0 0 24 24" fill="none">
                    <path d="M12 8l-6 13l6-4l6 4l-6-13z" fill="#4a90e2"/>
                    <circle cx="12" cy="8" r="6" fill="#4a90e2"/>
                </svg>
            </button>
        </div>
    </div>
    <div class="confirmation-popup" id="confirmationPopup">
        <p>Построить маршрут до выбранной точки?</p>
        <div class="confirmation-buttons">
            <button class="confirm-yes" id="confirmYes">Да</button>
            <button class="confirm-no" id="confirmNo">Нет</button>
        </div>
    </div>
    <div id="navigation-panel" class="navigation-panel hidden">
        <div class="nav-header">
            <span id="distance-remaining">-- км</span>
            <span id="time-remaining">-- мин</span>
        </div>
        <div class="nav-instruction" id="current-instruction">
            <!-- Текущая инструкция -->
        </div>
        <div class="nav-controls">
            <button id="startNavigation">Начать</button>
            <button id="stopNavigation">Завершить</button>
        </div>
    </div>

    <script src='https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.1/maps/maps-web.min.js'></script>
    <script src='https://api.tomtom.com/maps-sdk-for-web/cdn/6.x/6.25.1/services/services-web.min.js'></script>
    <script data-showable type='text/javascript' src='../assets/js/mobile-or-tablet.js'></script>
    <script data-showable type='text/javascript' src='../assets/js/foldable.js'></script>
    <script data-showable type='text/javascript' src='../assets/js/info-hint.js'></script>
    <script data-showable type='text/javascript' src='../assets/js/search/searchbox-enter-submit.js'></script>
    <script src='https://api.tomtom.com/maps-sdk-for-web/cdn/plugins/SearchBox/3.2.0/SearchBox-web.js'></script>
    <script>
        var routeMarkers = {}, routePoints = {}, searchBoxes = {};
        var finishMarkerElement = createMarkerElement('finish');
        var startMarkerElement = createMarkerElement('start');
        var errorHint = new InfoHint('error', 'bottom-center', 5000).addTo(document.getElementById('map'));
        var loadingHint = new InfoHint('info', 'bottom-center').addTo(document.getElementById('map'));
        var routeCoordinates = [];
        var routePoints = {};
        var searchBoxes = {};
        var weatherMarkers = [];
        let userWeatherMarkers = [];
        let routeWeatherMarkers = [];
        var weatherPopups = [];
        var followUser = true;
        var weatherZoomLevel = 12; // Set the zoom level at which weather will be displayed
        var weatherGridSize = 200; // Size of the grid around the user in meters
        const weatherCache = new Map();
        const CACHE_DURATION = 10 * 60 * 1000; // 10 минут
        let weatherUpdateTimeout;
        const WEATHER_UPDATE_DELAY = 200; // 1 секунда
        // Константы для погоды
        const WEATHER_ZOOM_LEVEL = 12; // Минимальный зум для показа погоды
        const GRID_SIZE = 500; // Размер сетки в метрах
        const WEATHER_ICONS = {
            'snow': '❄️',
            'rain': '🌧️',
            'clouds': '☁️',
            'clear': '☀️'
        };
        const LOCATION_OPTIONS = {
            enableHighAccuracy: true, // Высокая точность
            maximumAge: 0,           // Всегда получать свежие данные
            timeout: 1000            // Таймаут в 5 секунд
        };
        const WEATHER_UPDATE_INTERVAL = 10 * 60 * 1000; // 10 минут вместо 5
        const WEATHER_CACHE_DURATION = 30 * 60 * 1000; // 30 минут кэширования
        const MIN_UPDATE_INTERVAL = 1000; // Минимальный интервал между обновлениями
        let weatherUpdateInterval;
        let isNavigating = false;
        let currentRouteIndex = 0;
        const speechSynthesis = window.speechSynthesis;

        function clearRouteWeatherMarkers() {
            routeWeatherMarkers.forEach(marker => marker.remove());
            routeWeatherMarkers = [];
        }

        async function updateUserWeather(userLocation) {
            try {
                clearUserWeatherMarkers();

                const grid = createWeatherGrid(userLocation, GRID_SIZE);

                for (const point of grid) {
                    try {
                        const weather = await getWeather(point[1], point[0]);
                        const marker = createWeatherMarker(weather, point, false);
                        if (marker) {
                            userWeatherMarkers.push(marker);
                        }
                    } catch (error) {
                        console.error('Error processing user weather point:', error);
                    }
                }
            } catch (error) {
                console.error('Error in updateUserWeather:', error);
            }
        }

        function clearUserWeatherMarkers() {
            userWeatherMarkers.forEach(marker => {
                if (marker) {
                    marker.remove();
                    markerPool.push(marker);
                }
            });
            userWeatherMarkers = [];
        }
        function startNavigation() {
            isNavigating = true;
            followUser = true;
            document.getElementById('navigation-panel').classList.remove('hidden');
            
            // Get current user position and next route point
            if (userMarker && routeCoordinates && routeCoordinates.length > 1) {
                const userLocation = userMarker.getLngLat();
                const nextPoint = routeCoordinates[1]; // Next point in route
                
                // Calculate initial bearing to next point
                const bearing = calculateBearing(
                    [userLocation.lng, userLocation.lat],
                    nextPoint
                );
                
                // Immediate camera update with bearing
                map.easeTo({
                    center: [userLocation.lng, userLocation.lat],
                    bearing: bearing,
                    pitch: 60,
                    zoom: 18,
                    duration: 1000
                });
            }
            
            updateNavigationInfo();
        }

        function stopNavigation() {
            isNavigating = false;
            followUser = false;
            document.getElementById('navigation-panel').classList.add('hidden');
        }

        function updateNavigationInfo() {
            if (!isNavigating || !routeCoordinates) return;

            const userLocation = userMarker.getLngLat();
            let minDistance = Infinity;
            let nearestIndex = 0;

            // Находим ближайшую точку маршрута
            routeCoordinates.forEach((point, index) => {
                const d = calculateDistance([userLocation.lng, userLocation.lat], point);
                if (d < minDistance) {
                    minDistance = d;
                    nearestIndex = index;
                }
            });

            // Обновляем информацию о маршруте
            const remainingPoints = routeCoordinates.slice(nearestIndex);
            const remainingDistance = calculateRouteDistance(remainingPoints);
            const estimatedTime = calculateEstimatedTime(remainingDistance);
            
            document.getElementById('distance-remaining').textContent = 
                `${(remainingDistance/1000).toFixed(1)} км`;
            document.getElementById('time-remaining').textContent = 
                `${Math.round(estimatedTime)} мин`;

            // Определяем следующий маневр
            if (nearestIndex < routeCoordinates.length - 1) {
                const nextPoint = routeCoordinates[nearestIndex + 1];
                const bearing = calculateBearing([userLocation.lng, userLocation.lat], nextPoint);
                const instruction = getNavigationInstruction(bearing);
                
                document.getElementById('current-instruction').textContent = instruction;
                
                // Голосовая подсказка при приближении к повороту
                if (minDistance < 50) { // 50 метров до поворота
                    speakInstruction(instruction);
                }
            }
        }

        // Function to divide route into segments every 'interval' meters
        function divideRouteIntoSegments(coordinates, interval) {
            const segments = [];
            let accumulatedDistance = 0;
            let lastPoint = coordinates[0];
            segments.push(lastPoint);

            for (let i = 1; i < coordinates.length; i++) {
                const currentPoint = coordinates[i];
                const distance = calculateDistance(lastPoint, currentPoint);
                accumulatedDistance += distance;

                if (accumulatedDistance >= interval) {
                    segments.push(currentPoint);
                    accumulatedDistance = 0;
                }

                lastPoint = currentPoint;
            }

            return segments;
        }


        // Function to fetch weather data for each segment point
        async function fetchWeatherForSegments(segments) {
            console.log('Fetching weather for segments:', segments.length);
            const weatherPromises = segments.map(async (point, index) => {
                console.log(`Fetching weather for segment ${index}:`, point);
                const weather = await getWeather(point[1], point[0]);
                return { point, weather };
            });

            return Promise.all(weatherPromises);
        }
        // Function to create and display weather markers on the map
        function displayWeatherMarkers(weatherData) {
            console.log('Displaying weather markers:', weatherData.length);
            
            // Clear existing markers
            routeWeatherMarkers.forEach(marker => marker.remove());
            routeWeatherMarkers = [];

            weatherData.forEach(({ point, weather }) => {
                const marker = createWeatherMarker(weather, point);
                if (marker) {
                    routeWeatherMarkers.push(marker);
                }
            });

            console.log('Created weather markers:', routeWeatherMarkers.length);
        }

        function calculateRouteDistance(points) {
            let distance = 0;
            for (let i = 0; i < points.length - 1; i++) {
                distance += calculateDistance(points[i], points[i + 1]);
            }
            return distance;
        }

        function calculateEstimatedTime(distance) {
            const avgSpeed = 40; // km/h
            return (distance / 1000) / (avgSpeed / 60); // минуты
        }

        function getNavigationInstruction(bearing) {
            if (bearing < 22.5) return "Двигайтесь прямо";
            if (bearing < 67.5) return "Поверните направо";
            if (bearing < 112.5) return "Развернитесь";
            if (bearing < 157.5) return "Поверните налево";
            return "Двигайтесь прямо";
        }

        function speakInstruction(instruction) {
            // Don't speak if already speaking or if instruction is "straight ahead"
            if (speechSynthesis.speaking || instruction === "Двигайтесь прямо") return;
            
            const utterance = new SpeechSynthesisUtterance(instruction);
            utterance.lang = 'ru-RU';
            speechSynthesis.speak(utterance);
        }
        
        // Функция создания точек сетки вокруг пользователя
        function createWeatherGrid(userLocation, gridSize) {
            const points = [];
            const offset = gridSize / 111111; // Примерное преобразование метров в градусы
            const minDistance = 100; // Минимальное расстояние в метрах

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const point = [
                        userLocation[0] + j * offset,
                        userLocation[1] + i * offset
                    ];
                    
                    // Проверяем расстояние до пользователя
                    const distance = calculateDistance(userLocation, point);
                    
                    // Добавляем точку только если она достаточно далеко от пользователя
                    if (distance > minDistance) {
                        points.push(point);
                    }
                }
            }
            return points;
        }
        // Функция для запуска периодического обновления погоды
        function startWeatherUpdates(userLocation) {
            // Очищаем предыдущий интервал если есть
            if (weatherUpdateInterval) {
                clearInterval(weatherUpdateInterval);
            }

            // Создаем новый интервал
            weatherUpdateInterval = setInterval(() => {
                if (map.getZoom() >= WEATHER_ZOOM_LEVEL) {
                    updateWeather(userLocation);
                }
            }, WEATHER_UPDATE_INTERVAL);
        }
        // Оптимизированная функция получения погоды
        async function getWeather(lat, lon) {
            const key = `${lat},${lon}`;
            const now = Date.now();
            
            // Проверяем кэш
            if (weatherCache.has(key)) {
                const cachedData = weatherCache.get(key);
                if (now - cachedData.timestamp < CACHE_DURATION) {
                    return cachedData.weather;
                }
            }

            try {
                const API_KEY = '2743b4a0f99648c34789d9dcfb3ad81d';
                const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}`);
                const data = await response.json();
                const weather = data.weather[0].main.toLowerCase();
                
                // Сохраняем в кэш
                weatherCache.set(key, {
                    weather,
                    timestamp: now
                });
                
                return weather;
            } catch (error) {
                console.error('Error fetching weather:', error);
                return 'clear';
            }
        }

        // Дебаунсинг обновления погоды
        function debouncedUpdateWeather(userLocation) {
            console.log('Debounce called for weather update');
            if (weatherUpdateTimeout) {
                console.log('Clearing previous timeout');
                clearTimeout(weatherUpdateTimeout);
            }
            
            weatherUpdateTimeout = setTimeout(() => {
                console.log('Executing delayed weather update');
                updateWeather(userLocation);
            }, WEATHER_UPDATE_DELAY);
        }
        // Функция создания маркера погоды
        const markerPool = [];
        function createWeatherMarker(weather, lngLat, isFinishPoint = false) {
            logWeatherDebug('Creating weather marker:', { weather, lngLat });
            
            try {
                const markerElement = document.createElement('div');
                markerElement.className = 'weather-marker';
                
                // Force size and visibility
                markerElement.style.cssText = `
                    width: 50px;
                    height: 50px;
                    background-size: contain;
                    background-repeat: no-repeat;
                    background-position: center;
                    background-image: url(assets/weather/${weather}.png);
                    display: block !important;
                    opacity: 1 !important;
                    pointer-events: auto !important;
                `;

                const marker = new tt.Marker({
                    element: markerElement,
                    anchor: 'center'
                }).setLngLat(lngLat);

                // Force marker to map
                marker.addTo(map);
                logWeatherDebug('Marker added to map:', { weather, lngLat });
                if (isFinishPoint) {
                    if (finishWeatherMarker) {
                        finishWeatherMarker.remove();
                    }
                    finishWeatherMarker = marker;
                } else {
                    weatherMarkers.push(marker);
                }
                return marker;
            } catch (error) {
                console.error('Error creating weather marker:', error);
                return null;
            }

        }
        let routeWeatherState = {
            markers: [],
            coordinates: [],
            exists: false
        };
        function clearWeatherMarkers() {
            if (weatherMarkers.length) {
                weatherMarkers.forEach(marker => {
                    if (marker) {
                        marker.remove();
                        markerPool.push(marker); // Возвращаем в пул
                    }
                });
                weatherMarkers = [];
            }
        }
        function logWeatherDebug(message, data) {
            console.log(`[Weather Debug] ${message}`, data);
        }

        // Улучшенная функция обновления погоды
        async function updateWeather(userLocation) {
            try {
                // Очищаем только маркеры вокруг пользователя
                weatherMarkers.forEach(marker => marker.remove());
                weatherMarkers = [];

                const grid = createWeatherGrid(userLocation, GRID_SIZE);

                for (const point of grid) {
                    try {
                        const weather = await getWeather(point[1], point[0]);
                        const marker = createWeatherMarker(weather, point, false); // false означает, что это не маркер маршрута
                        if (marker) {
                            weatherMarkers.push(marker);
                        }
                    } catch (error) {
                        console.error('Error processing grid point:', error);
                    }
                }
            } catch (error) {
                console.error('Error in updateWeather:', error);
            }
        }

        // Initialize the map
        var userMarker;
        function handleDeviceOrientation(event) {
            if (!event.alpha) return;
            
            // Convert compass heading to bearing
            let bearing = event.alpha;
            if (event.webkitCompassHeading) {
                // iOS devices
                bearing = event.webkitCompassHeading;
            } else {
                // Android devices
                bearing = 360 - event.alpha;
            }

            if (userMarker) {
                userMarker.setRotation(bearing);
                
                // If in navigation mode, rotate map to match device orientation
                if (isNavigating && followUser) {
                    map.easeTo({
                        bearing: bearing,
                        duration: 300
                    });
                }
            }
        }
        function updateNavigationBearing(userLocation, nextPoint) {
            const bearing = calculateBearing(
                [userLocation.lng, userLocation.lat],
                nextPoint
            );
            
            if (isNavigating && followUser) {
                map.easeTo({
                    bearing: bearing,
                    duration: 1000
                });
            }
            
            return bearing;
        }

        // Request device orientation permissions and start tracking
        async function enableOrientationTracking() {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission === 'granted') {
                        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
                    }
                } catch (error) {
                    console.error('Error requesting orientation permission:', error);
                }
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            }
        }
        var map = tt.map({
            key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
            container: 'map',
            dragPan: true, // Разрешаем перемещение карты на всех устройствах
            zoom: 15,
            center: [51.505, -0.09],
            preferCanvas: true
        });
        // Добавить после инициализации карты
        document.addEventListener('DOMContentLoaded', function() {
            // Получаем элементы управления
            const navigationPanel = document.getElementById('navigation-panel');
            const startButton = document.getElementById('startNavigation');
            const stopButton = document.getElementById('stopNavigation');

            // Обработчики для кнопок
            startButton.addEventListener('click', function() {
                isNavigating = true;
                followUser = true;
                navigationPanel.classList.remove('hidden');
                
                // Установка начального вида
                if (userMarker) {
                    const userLocation = userMarker.getLngLat();
                    map.easeTo({
                        center: userLocation,
                        zoom: 18,
                        pitch: 60,
                        duration: 1000
                    });
                }
                
                // Запуск обновления информации
                updateNavigationInfo();
            });

            stopButton.addEventListener('click', function() {
                isNavigating = false;
                followUser = false;
                navigationPanel.classList.add('hidden');
            });

            // Регулярное обновление информации о маршруте
            setInterval(() => {
                if (isNavigating && routeCoordinates) {
                    updateNavigationInfo();
                }
            }, 1000);
        });
        map.addControl(new tt.FullscreenControl());
        map.addControl(new tt.NavigationControl());
        new Foldable('#foldable', 'top-right');
        function calculateBearing(start, end) {
            const startLat = start[1] * Math.PI / 180;
            const startLng = start[0] * Math.PI / 180;
            const endLat = end[1] * Math.PI / 180;
            const endLng = end[0] * Math.PI / 180;

            const y = Math.sin(endLng - startLng) * Math.cos(endLat);
            const x = Math.cos(startLat) * Math.sin(endLat) -
                Math.sin(startLat) * Math.cos(endLat) * Math.cos(endLng - startLng);
            const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
            return bearing;
        }
        function calculateDistance(point1, point2) {
            const lat1 = point1[1] * Math.PI / 180;
            const lat2 = point2[1] * Math.PI / 180;
            const lon1 = point1[0] * Math.PI / 180;
            const lon2 = point2[0] * Math.PI / 180;
            
            const R = 6371e3; // радиус Земли в метрах
            const x = (lon2 - lon1) * Math.cos((lat1 + lat2) / 2);
            const y = (lat2 - lat1);
            const d = Math.sqrt(x * x + y * y) * R;
            
            return d;
        }
        
        function createArrowMarker() {
            const markerDiv = document.createElement('div');
            markerDiv.className = 'draggable-marker';
            markerDiv.style.width = '32px';
            markerDiv.style.height = '32px';

            // Updated SVG with correct initial rotation
            const svg = `
            <svg width="32px" height="32px" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                <circle cx="16" cy="16" r="14" fill="#4a90e2" stroke="#2faaff" stroke-width="2"/>
                <path d="M16 8L20 24L16 20L12 24L16 8Z" fill="#ffffff"/>
            </svg>`;

            markerDiv.innerHTML = svg;
            return markerDiv;
        }
    


        function createUserMarker(position) {
            if (!userMarker) {
                const markerElement = createArrowMarker();
                userMarker = new tt.Marker({
                    draggable: true,
                    element: markerElement,
                    rotationAlignment: 'map',
                    pitchAlignment: 'map'
                })
                .setLngLat([position.coords.longitude, position.coords.latitude])
                .addTo(map);

                userMarker.on('dragend', function() {
                    const newPos = userMarker.getLngLat();
                    routePoints.start = [newPos.lng, newPos.lat];
                    if (routePoints.finish) {
                        handleDrawRoute('finish');
                    }
                });
            }
            return userMarker;
        }
        function debouncedUpdateWeather(userLocation) {
            console.log('Debounce called for weather update');
            if (weatherUpdateTimeout) {
                console.log('Clearing previous timeout');
                clearTimeout(weatherUpdateTimeout);
            }
            
            weatherUpdateTimeout = setTimeout(() => {
                console.log('Executing delayed weather update');
                updateWeather(userLocation);
            }, WEATHER_UPDATE_DELAY);
        }

        map.on('zoomend', function() {
            if (userMarker) {
                const userLocation = userMarker.getLngLat();
                const currentZoom = map.getZoom();
                
                if (currentZoom < WEATHER_ZOOM_LEVEL) {
                    clearUserWeatherMarkers();
                } else {
                    debouncedUpdateUserWeather([userLocation.lng, userLocation.lat]);
                }

                // Маркеры маршрута всегда остаются видимыми
                if (routeWeatherState.exists) {
                    routeWeatherState.markers.forEach(marker => {
                        if (!marker.getElement().isConnected) {
                            marker.addTo(map);
                        }
                    });
                }
            }
        });

        map.on('pitchend', function() {
            console.log('Pitch level: ', map.getPitch());
        });

        map.on('dragstart', function() {
            followUser = false;
        });
        // Initialize the geolocate control

        map.on('load', function() {
            let startX = 0;
            let startY = 0;
            let startBearing = 0;
            let isDragging = false;

            // Enable rotation
            map.touchZoomRotate.enable();
            map.touchZoomRotate.enableRotation();

            // Handle touch start
            map.getCanvas().addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    isDragging = true;
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];
                    startX = (touch1.clientX + touch2.clientX) / 2;
                    startY = (touch1.clientY + touch2.clientY) / 2;
                    startBearing = map.getBearing();
                }
            });

            // Handle touch move
            map.getCanvas().addEventListener('touchmove', function(e) {
                if (!isDragging || e.touches.length !== 2) return;

                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;

                // Calculate rotation angle
                const angle = Math.atan2(centerY - startY, centerX - startX) * 180 / Math.PI;
                
                // Update map bearing
                map.setBearing(startBearing + angle);
                
                e.preventDefault(); // Prevent default gestures
            });

            // Handle touch end
            map.getCanvas().addEventListener('touchend', function() {
                isDragging = false;
            });
            // Only create finish search box
            searchBoxes.finish = createSearchBox('finish');
            
            // Set initial user location as start point if available
            let lastUpdate = 0;
            var options = { enableHighAccuracy: true, maximumAge: 100, timeout: 10000 };
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(function(position, options) {
                    const userLocation = [position.coords.longitude, position.coords.latitude];
                    const heading = position.coords.heading || 0;
                    const now = Date.now();
                    if (now - lastUpdate < MIN_UPDATE_INTERVAL) return;
                    lastUpdate = now;
                    
                    // Обновляем маркер пользователя
                    if (!userMarker) {
                        userMarker = createUserMarker(position);
                    } else {
                        userMarker.setLngLat(userLocation);
                        userMarker.setRotation(heading);
                    }

                    // Обновляем позицию старта маршрута
                    routePoints.start = userLocation;

                    // Если включен режим следования и есть маршрут
                    if (followUser && routePoints.finish) {
                        // Находим ближайший сегмент маршрута
                        if (routeCoordinates && routeCoordinates.length > 1) {
                            let minDistance = Infinity;
                            let nearestIndex = 0;

                            // Ищем ближайшую точку маршрута
                            routeCoordinates.forEach((point, index) => {
                                const d = calculateDistance(userLocation, point);
                                if (d < minDistance) {
                                    minDistance = d;
                                    nearestIndex = index;
                                }
                            });

                            // Рассчитываем угол поворота к следующей точке маршрута
                            if (nearestIndex < routeCoordinates.length - 1) {
                                const nextPoint = routeCoordinates[nearestIndex + 1];
                                const bearing = calculateBearing(userLocation, nextPoint);

                                // Плавно поворачиваем карту
                                map.easeTo({
                                    center: userLocation,
                                    bearing: bearing,
                                    pitch: 60,
                                    duration: 1000
                                });
                            }
                        } else {
                            // Если маршрут не построен, просто следуем за пользователем
                            map.easeTo({
                                center: userLocation,
                                bearing: heading,
                                pitch: 60,
                                duration: 1000
                            });
                        }
                    }
                    if (map.getZoom() >= WEATHER_ZOOM_LEVEL) {
                        updateWeather([position.coords.longitude, position.coords.latitude]);
                    }
                    startWeatherUpdates(userLocation);
                }, 
                function(error) {
                    console.error('Error getting location:', error);
                },
                LOCATION_OPTIONS
                );
            }
        });
        function updateMapViewWithDirection(position) {
            map.easeTo({
                center: position,
                zoom: 18, // Увеличиваем zoom для лучшего обзора текущей локации
                pitch: 60, // Добавляем наклон для лучшего обзора маршрута
                duration: 1000 // Добавляем плавную анимацию
            });
        }

        document.getElementById('followButton').addEventListener('click', function() {
            followUser = true;
            if (userMarker) {
                var userLocation = userMarker.getLngLat();
                // Передаем только позицию, без поворота
                updateMapViewWithDirection(userLocation);
            }
        });

        function createSearchBox(type) {
            var searchBox = new tt.plugins.SearchBox(tt.services, {
                showSearchButton: false,
                searchOptions: {
                    key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5'
                },
                labels: {
                    placeholder: 'Куда хотите приехать?'
                }
            });

            document.getElementById(type + 'SearchBox').appendChild(searchBox.getSearchBoxHTML());
            searchBox.on('tomtom.searchbox.resultscleared', onResultCleared.bind(null, type));

            searchBox.on('tomtom.searchbox.resultsfound', function(event) {
                handleEnterSubmit(event, onResultSelected.bind(this), errorHint, type);
            });

            searchBox.on('tomtom.searchbox.resultselected', function(event) {
                if (event.data && event.data.result) {
                    onResultSelected(event.data.result, type);
                }
            });

            return searchBox;
        }

        function createMarkerElement(type) {
            const element = document.createElement('div');
            element.className = 'marker-container';

            if (type === 'finish') {
                element.innerHTML = `
                    <div class="finish-point-marker">
                        <div class="tt-icon -white -finish"></div>
                    </div>
                    <div class="weather-icon"></div>
                `;
            } else {
                element.className = 'draggable-marker';
                const innerElement = document.createElement('div');
                innerElement.className = 'tt-icon -white -' + type;
                element.appendChild(innerElement);
            }
            
            return element;
        }

        function updateFinishMarkerWeather(weather) {
            if (routeMarkers.finish) {
                const weatherIcon = routeMarkers.finish.getElement().querySelector('.weather-icon');
                if (weatherIcon) {
                    weatherIcon.style.backgroundImage = `url(assets/weather/${weather}.png)`;
                }
            }
        }

        function createMarker(type, lngLat) {
            var markerElement = type === 'start' ? startMarkerElement : finishMarkerElement;

            return new tt.Marker({ draggable: true, element: markerElement })
                .setLngLat(lngLat)
                .addTo(map)
                .on('dragend', getDraggedMarkerPosition.bind(null, type));
        }

        function getDraggedMarkerPosition(type) {
            var lngLat = routeMarkers[type].getLngLat();

            performReverseGeocodeRequest(lngLat)
                .then(function(response) {
                    var addresses = response.addresses[0];
                    var freeFormAddress = addresses.address.freeformAddress;

                    if (!freeFormAddress) {
                        loadingHint.hide();
                        clearMap();
                        errorHint.setMessage('Address not found, please choose a different place');
                        return;
                    }
                    searchBoxes[type]
                        .getSearchBoxHTML()
                        .querySelector('input.tt-search-box-input')
                        .value = freeFormAddress;
                    var position = {
                        lng: addresses.position.lng,
                        lat: addresses.position.lat
                    };

                    updateMapView(type, position);
                });
        }

        function onResultCleared(type) {
            routePoints[type] = null;
            if (routeMarkers[type]) {
                routeMarkers[type].remove();
                routeMarkers[type] = null;
            }
            if (routePoints.start || routePoints.finish) {
                var lngLat = type === 'start' ? routePoints.finish : routePoints.start;
                clearMap();
                centerMap(lngLat);
            }
        }
        function onResultSelected(result, type) {
            var position = result.position;
            
            // Обновляем точку финиша
            if (type === 'finish') {
                routePoints.finish = [position.lng, position.lat];
                
                // Создаем или обновляем маркер финиша
                if (routeMarkers.finish) {
                    routeMarkers.finish.remove(); // Удаляем старый маркер
                }
                
                // Создаем новый маркер финиша
                routeMarkers.finish = new tt.Marker({
                    element: finishMarkerElement
                })
                .setLngLat([position.lng, position.lat])
                .addTo(map);

                getFinishPointWeather(position.lat, position.lng)
                    .then(weather => {
                        createFinishWeatherMarker(weather, [position.lng, position.lat]);
                    });
                // Проверяем наличие стартовой точки и строим маршрут
                if (userMarker) {
                    var startPos = userMarker.getLngLat();
                    routePoints.start = [startPos.lng, startPos.lat];
                    handleDrawRoute('finish');
                }
            }
        }

        function performCalculateRouteRequest() {
            if (!routePoints.start || !routePoints.finish) {
                return Promise.reject('Missing start or finish point');
            }
            return tt.services.calculateRoute({
                key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
                traffic: false,
                locations: routePoints.start.join() + ':' + routePoints.finish.join()
            });
        }

        function performReverseGeocodeRequest(lngLat) {
            return tt.services.reverseGeocode({
                key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
                position: lngLat
            });
        }

        function updateMapView(type, position) {
            // Убедимся, что координаты сохраняются в правильном формате
            routePoints[type] = [position.lng, position.lat];
            console.log('Updated route points:', routePoints);

            if (routePoints.start && routePoints.finish) {
                handleDrawRoute(type);
            } else {
                addRouteMarkers(type);
                centerMap(routePoints[type]);
            }
        }
        /*function updateUserLocation(position) {
            var userLocation = [position.coords.longitude, position.coords.latitude];
            var heading = position.coords.heading || 0;
            
            if (!userMarker) {
                userMarker = new tt.Marker({
                    draggable: true,
                    element: createArrowMarker(),
                    rotationAlignment: 'map'
                })
                .setLngLat(userLocation)
                .addTo(map);
                
                userMarker.on('dragend', function() {
                    var newPos = userMarker.getLngLat();
                    routePoints.start = [newPos.lng, newPos.lat];
                    if (routePoints.finish) {
                        handleDrawRoute('finish');
                    }
                });
            } else {
                userMarker.setLngLat(userLocation);
                userMarker.setRotation(heading);
            }
            
            routePoints.start = userLocation;
            if (routePoints.finish && followUser) {
                handleDrawRoute('finish');
            }
        }*/
        function updateUserLocation(position) {
            const { longitude, latitude, accuracy, heading } = position.coords;
            const userLocation = [longitude, latitude];

            if (!userMarker) {
                userMarker = new tt.Marker({
                    draggable: true,
                    element: createArrowMarker(),
                    rotationAlignment: 'map'
                }).setLngLat(userLocation)
                  .addTo(map);
                userMarker.on('dragend', function() {
                    var newPos = userMarker.getLngLat();
                    routePoints.start = [newPos.lng, newPos.lat];
                    if (routePoints.finish) {
                        handleDrawRoute('finish');
                    }
                });
            } else {
                // Smooth animation for marker movement
                /*userMarker.animate({ 
                    coordinates: [longitude, latitude],
                    duration: 1000,
                    easing: 'linear'
                });*/
                userMarker.setLngLat(userLocation);
                userMarker.setRotation(heading);
                if (followUser) {
                    map.easeTo({
                        center: userLocation,
                        duration: 1000
                    });
                }
            }
            routePoints.start = userLocation;
            if (routePoints.finish && followUser) {
                handleDrawRoute('finish');
            }
            if (followUser) {
                // Smooth map movement
                map.easeTo({
                    center: userLocation,
                    duration: 1000
                });
            }
        }
      
    
        let isDrivingMode = false;

        function enableDrivingMode() {
            isDrivingMode = true;
            
            // Adjust map settings for driving
            map.easeTo({
                bearing: bearing,
                pitch: 60,
                duration: 1000,
                zoom: 17
            });
            //map.setPit(60); // Tilt map for better road view
            //map.setZoom(17); // Closer zoom for driving
            
            // Update UI for driving mode
            document.body.classList.add('driving-mode');
            
            // Enable auto-follow
            followUser = true;
            
            // Update map style for better road visibility
            map.setStyle({
                'style': 'tomtom://vector/1/basic-main',
                'layer': 'basic',
                'roads': true
            });
        }

        let routeExists = false;

        // Обновим функцию создания маркеров погоды на маршруте
        async function createRouteWeatherMarkers(coordinates) {
            // Если маршрут уже существует и координаты те же, не пересоздаем маркеры
            if (routeWeatherState.exists && 
                JSON.stringify(coordinates) === JSON.stringify(routeWeatherState.coordinates)) {
                return;
            }

            // Очищаем старые маркеры
            clearRouteWeatherMarkers();

            // Создаем точки каждые 5км
            const segments = divideRouteIntoSegments(coordinates, 5000);
            
            for (const point of segments) {
                try {
                    const weather = await getWeather(point[1], point[0]);
                    const marker = createWeatherMarker(weather, point);
                    if (marker) {
                        routeWeatherState.markers.push(marker);
                    }
                } catch (error) {
                    console.error('Error creating route weather marker:', error);
                }
            }

            // Сохраняем состояние
            routeWeatherState.coordinates = coordinates;
            routeWeatherState.exists = true;
        }

        // Обновим функцию очистки маркеров
        function clearRouteWeatherMarkers() {
            routeWeatherState.markers.forEach(marker => marker.remove());
            routeWeatherState.markers = [];
            routeWeatherState.exists = false;
        }
        function handleDrawRoute(type) {
            if (!routePoints.start || !routePoints.finish) {
                console.log('Missing route points:', routePoints);
                return;
            }

            errorHint.hide();
            loadingHint.setMessage('Строим маршрут...');
            clearMap(false);

            const startCoords = Array.isArray(routePoints.start) ? 
                routePoints.start.join(',') : 
                `${routePoints.start[0]},${routePoints.start[1]}`;
            
            const finishCoords = Array.isArray(routePoints.finish) ? 
                routePoints.finish.join(',') : 
                `${routePoints.finish[0]},${routePoints.finish[1]}`;

            tt.services.calculateRoute({
                key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
                traffic: false,
                locations: `${startCoords}:${finishCoords}`
            })
            .then(async function(response) {
                const geojson = response.toGeoJson();

                // Add route layer
                map.addLayer({
                    'id': 'route',
                    'type': 'line',
                    'source': {
                        'type': 'geojson',
                        'data': geojson
                    },
                    'paint': {
                        'line-color': '#4a90e2',
                        'line-width': 6
                    }
                });

                // Save route coordinates
                routeCoordinates = geojson.features[0].geometry.coordinates;
                await createRouteWeatherMarkers(routeCoordinates);
                // Fetch weather data and display markers
                //const weatherData = await fetchWeatherForSegments(segments);
                //displayWeatherMarkers(weatherData);
                // Calculate initial bearing to next waypoint
                if (userMarker && routeCoordinates.length > 1) {
                    const userLocation = userMarker.getLngLat();
                    const nextPoint = routeCoordinates[1];
                    
                    const bearing = calculateBearing(
                        [userLocation.lng, userLocation.lat],
                        nextPoint
                    );

                    // Set navigation view immediately
                    map.easeTo({
                        center: [userLocation.lng, userLocation.lat],
                        bearing: bearing,
                        pitch: 60,
                        zoom: 17,
                        duration: 1000
                    });

                    // Enable driving mode with calculated bearing
                    enableDrivingMode(bearing);
                }

                // Show navigation panel
                document.getElementById('navigation-panel').classList.remove('hidden');
                loadingHint.hide();
            })
            .catch(function(error) {
                console.error('Route calculation error:', error);
                errorHint.setMessage('Ошибка построения маршрута');
                loadingHint.hide();
            });
        }

        function clearRouteWeatherMarkers() {
            routeWeatherMarkers.forEach(marker => marker.remove());
            routeWeatherMarkers = [];
        }
        function enableDrivingMode(bearing) {
            isDrivingMode = true;
            followUser = true;
            
            // Keep the calculated bearing and navigation settings
            if (bearing !== undefined) {
                map.easeTo({
                    bearing: bearing,
                    pitch: 60,
                    zoom: 17,
                    duration: 1000
                });
            }
            
            document.body.classList.add('driving-mode');
        }

        function performCalculateRouteRequest() {
            // Добавляем проверку и логирование
            console.log('Start point:', routePoints.start);
            console.log('Finish point:', routePoints.finish);

            if (!routePoints.start || !routePoints.finish) {
                return Promise.reject('Missing start or finish point');
            }

            // Убедимся, что координаты в правильном формате
            const startCoords = Array.isArray(routePoints.start) ? 
                routePoints.start.join(',') : 
                `${routePoints.start.lng},${routePoints.lat}`;
            
            const finishCoords = Array.isArray(routePoints.finish) ? 
                routePoints.finish.join(',') : 
                `${routePoints.finish.lng},${routePoints.finish.lat}`;

            console.log('Route request:', `${startCoords}:${finishCoords}`);

            return tt.services.calculateRoute({
                key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
                traffic: false,
                locations: `${startCoords}:${finishCoords}`
            })
            .then(response => {
                console.log('Route calculated successfully');
                return response;
            })
            .catch(error => {
                console.error('Route calculation error:', error);
                throw error;
            });
        }
        function performReverseGeocodeRequest(lngLat) {
            return tt.services.reverseGeocode({
                key: 'poNLFAmAjT4yDNfltAgseReaM8872GV5',
                position: lngLat
            });
        }
        function addRouteMarkers(type, point) {
            var lngLat = point && point[type + 'Point'] || routePoints[type];

            if (!routeMarkers[type] && routePoints[type]) {
                routeMarkers[type] = createMarker(type, lngLat);
            }
            if (routeMarkers[type]) {
                routeMarkers[type].setLngLat(routePoints[type]);
            }
        }

        function clearMap(fullClear = false) {
            if (map.getLayer('route')) {
                map.removeLayer('route');
                map.removeSource('route');
            }

            if (fullClear) {
                clearUserWeatherMarkers();
                clearRouteWeatherMarkers();
            }
        }

        function centerMap(lngLat) {
            map.flyTo({
                center: lngLat,
                speed: 10,
                zoom: 8
            });
        }
        // Add map click handler and confirmation logic
        let tempFinishPoint = null;

        map.on('click', function(e) {
            tempFinishPoint = [e.lngLat.lng, e.lngLat.lat];
            document.getElementById('confirmationPopup').style.display = 'block';
        });

        document.getElementById('confirmYes').addEventListener('click', async function() {
            if (tempFinishPoint) {
                // Get coordinates
                const position = {
                    lng: tempFinishPoint[0],
                    lat: tempFinishPoint[1]
                };
                // Update finish point
                routePoints.finish = [position.lng, position.lat];
                
                // Update or create finish marker
                if (routeMarkers.finish) {
                    routeMarkers.finish.remove();
                }
                
                routeMarkers.finish = new tt.Marker({
                    element: finishMarkerElement
                })
                .setLngLat([position.lng, position.lat])
                .addTo(map);

                const weather = await getWeather(position.lat, position.lng);
                
                // Create weather marker using existing function
                createWeatherMarker(weather, [position.lng, position.lat], true);
                // Update search box with coordinates
                searchBoxes.finish
                    .getSearchBoxHTML()
                    .querySelector('input.tt-search-box-input')
                    .value = `${position.lat.toFixed(6)}, ${position.lng.toFixed(6)}`;

                // Check if we have start point (user location)
                if (userMarker) {
                    const userLocation = userMarker.getLngLat();
                    routePoints.start = [userLocation.lng, userLocation.lat];
                    handleDrawRoute('finish');
                }
                
            }
            document.getElementById('confirmationPopup').style.display = 'none';
            tempFinishPoint = null;
        });

        document.getElementById('confirmNo').addEventListener('click', function() {
            document.getElementById('confirmationPopup').style.display = 'none';
            tempFinishPoint = null;
        });
        window.addEventListener('beforeunload', () => {
            if (weatherUpdateInterval) {
                clearInterval(weatherUpdateInterval);
            }
        });
        document.getElementById('startNavigation').addEventListener('click', function() {
            document.body.classList.add('navigation-active');
            const followButton = document.getElementById('followButton');
            const resetButton = document.getElementById('resetButton');
            const windButton = document.getElementById('windButton');
            
            followButton.style.bottom = '120px';
            resetButton.style.bottom = '180px';
            windButton.style.bottom = '240px';
        });

        document.getElementById('stopNavigation').addEventListener('click', function() {
            document.body.classList.remove('navigation-active');

            const followButton = document.getElementById('followButton');
            const resetButton = document.getElementById('resetButton');
            const windButton = document.getElementById('windButton');
            followButton.style.bottom = '30px';
            resetButton.style.bottom = '90px';
            windButton.style.bottom = '150px';
        });
        // Initialize orientation tracking
        document.addEventListener('DOMContentLoaded', () => {
            enableOrientationTracking();
        });

        // Update marker smoothly on position changes
        navigator.geolocation.watchPosition(updateUserLocation, null, LOCATION_OPTIONS);
        // Add click handler
        document.getElementById('resetButton').addEventListener('click', function() {
            // Clear route
            if (map.getLayer('route')) {
                map.removeLayer('route');
                map.removeSource('route');
            }
            
            // Remove finish marker
            if (routeMarkers.finish) {
                routeMarkers.finish.remove();
                routeMarkers.finish = null;
            }
            if (finishWeatherMarker) {
                finishWeatherMarker.remove();
                finishWeatherMarker = null;
            }
            weatherMarkers.forEach(marker => marker.remove());
            weatherMarkers = [];
            // Clear route points
            clearMap(true); // Full clear including weather markers
            routePoints.finish = null;
            
            // Clear search box
            if (searchBoxes.finish) {
                searchBoxes.finish.getSearchBoxHTML().querySelector('input.tt-search-box-input').value = '';
            }
            
            // Hide navigation panel if visible
            document.getElementById('navigation-panel').classList.add('hidden');
            isNavigating = false;
        });
        const OPENWEATHER_API_KEY = '2743b4a0f99648c34789d9dcfb3ad81d';
       
        // Add these variables at the top
        let geolocationRetries = 0;
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 2000; // 2 seconds
        let lastKnownPosition = null;

        // Enhanced geolocation handling
        function initGeolocation() {
            const options = {
                enableHighAccuracy: true,
                timeout: 10000,        // 10 second timeout
                maximumAge: 1000      // Accept cached positions up to 1 second old
            };

            function onSuccess(position) {
                geolocationRetries = 0;
                lastKnownPosition = position;
                updateUserLocation(position);
                hideGeolocationError();
            }

            function onError(error) {
                console.error('Geolocation error:', error);
                
                // Show specific error messages
                let errorMsg = '';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        errorMsg = 'Пожалуйста, разрешите доступ к геолокации';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        errorMsg = 'Информация о местоположении недоступна';
                        break;
                    case error.TIMEOUT:
                        errorMsg = 'Истекло время ожидания определения местоположения';
                        break;
                    default:
                        errorMsg = 'Произошла ошибка при определении местоположения';
                }

                showGeolocationError(errorMsg);

                // Retry logic
                if (geolocationRetries < MAX_RETRIES) {
                    geolocationRetries++;
                    setTimeout(() => {
                        navigator.geolocation.getCurrentPosition(onSuccess, onError, options);
                    }, RETRY_DELAY);
                }

                // Use last known position if available
                if (lastKnownPosition) {
                    updateUserLocation(lastKnownPosition);
                }
            }

            // Start watching position with enhanced error handling
            const watchId = navigator.geolocation.watchPosition(onSuccess, onError, options);

            // Periodic position check
            setInterval(() => {
                navigator.geolocation.getCurrentPosition(onSuccess, onError, options);
            }, 10000); // Check every 10 seconds

            return watchId;
        }

        // Add error display functions
        function showGeolocationError(message) {
            let errorDiv = document.getElementById('geolocation-error');
            if (!errorDiv) {
                errorDiv = document.createElement('div');
                errorDiv.id = 'geolocation-error';
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(255, 0, 0, 0.8);
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 1000;
                `;
                document.body.appendChild(errorDiv);
            }
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideGeolocationError() {
            const errorDiv = document.getElementById('geolocation-error');
            if (errorDiv) {
                errorDiv.style.display = 'none';
            }
        }
        // Add global variable for finish weather marker
        let finishWeatherMarker = null;

        // Function to get weather at finish point
        async function getFinishPointWeather(lat, lon) {
            try {
                const API_KEY = '2743b4a0f99648c34789d9dcfb3ad81d';
                const response = await fetch(
                    `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric`
                );
                const data = await response.json();
                return {
                    condition: data.weather[0].main.toLowerCase(),
                    temp: Math.round(data.main.temp),
                    wind: Math.round(data.wind.speed)
                };
            } catch (error) {
                console.error('Error fetching finish point weather:', error);
                return null;
            }
        }

        // Function to create/update finish weather marker
        function createFinishWeatherMarker(weatherData, lngLat) {
            if (finishWeatherMarker) {
                finishWeatherMarker.remove();
            }

            const markerElement = document.createElement('div');
            markerElement.className = 'finish-weather-marker';
            
            // Add weather icon
            const weatherIcon = document.createElement('div');
            weatherIcon.className = 'weather-icon';
            weatherIcon.style.backgroundImage = `url(assets/weather/${weatherData.condition}.png)`;
            
            // Add weather info
            const weatherInfo = document.createElement('div');
            weatherInfo.className = 'weather-info';
            weatherInfo.innerHTML = `
                <div>${weatherData.temp}°C</div>
                <div>${weatherData.wind} м/с</div>
            `;

            markerElement.appendChild(weatherIcon);
            markerElement.appendChild(weatherInfo);

            finishWeatherMarker = new tt.Marker({
                element: markerElement
            })
            .setLngLat(lngLat)
            .addTo(map);
        }

        // Update document.getElementById('confirmYes') click handler
        
        // Replace the existing geolocation initialization with:
        /*document.addEventListener('DOMContentLoaded', () => {
            enableOrientationTracking();
            initGeolocation();
        });*/

        // Modified getWindData function with error handling
        
    </script>
</body>
</html>